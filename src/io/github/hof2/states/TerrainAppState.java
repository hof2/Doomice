package io.github.hof2.states;

import com.jme3.app.Application;
import com.jme3.app.SimpleApplication;
import com.jme3.app.state.AbstractAppState;
import com.jme3.app.state.AppStateManager;
import com.jme3.bullet.BulletAppState;
import com.jme3.bullet.PhysicsSpace;
import com.jme3.bullet.control.RigidBodyControl;
import com.jme3.material.Material;
import com.jme3.math.Vector3f;
import com.jme3.scene.Node;
import com.jme3.terrain.geomipmap.TerrainQuad;
import com.jme3.terrain.heightmap.HillHeightMap;
import io.github.hof2.states.simple.Materials;
import io.github.hof2.states.simple.SimpleAppState;
import io.github.hof2.states.simple.SimpleMaterials;

/**
 * Handles and generates the in-game terrain.
 */
public class TerrainAppState extends SimpleAppState {

    private static final int PATCH_SIZE = 65;
    private static final int TOTAL_SIZE = 1025;
    private static final Vector3f LOCAL_TRANSLATION = new Vector3f(0, -120, 0);
    private static final int MAP_ITERATIONS = 512;
    private static final int MAP_MIN_RADIUS = 50;
    private static final int MAP_MAX_RADIUS = 120;
    private static final int MAP_NORMALIZE_RANGE = 100;
    private PhysicsSpace physicsSpace;
    private Node rootNode;
    private TerrainQuad terrain;
    private RigidBodyControl control = new RigidBodyControl(0);

    /**
     * Calls {@code initTerrain} and sets the {@code physicsSpace} and
     * {@code rootNode}.
     *
     * @see SimpleAppState
     * @see AbstractAppState
     * @param stateManager The state manager
     * @param app The application
     */
    @Override
    public void initialize(AppStateManager stateManager, Application app) {
        super.initialize(stateManager, app);

        physicsSpace = stateManager.getState(BulletAppState.class).getPhysicsSpace();
        rootNode = this.app.getRootNode();

        try {
            initTerrain();
        } catch (Exception ex) {
            System.out.println("TerrainAppState : HeightMap creation failed");
        }
    }

    /**
     * Generates a new {@link TerrainQuad} with a random
     * {@link HillHeightMap} generated by {@code getRandomHillHeightMap} and
     * attaches it to the {@code rootNode} and adds it to the
     * {@code physicsSpace}. The {@link TerrainQuad} is defined by
     * {@code PATCH_SIZE}, {@code TOTAL_SIZE} and {@code LOCAL_TRANSLATION}.
     *
     * @throws Exception is thrown when {@link HillHeightMap} creation fails.
     */
    private void initTerrain() throws Exception {
        terrain = new TerrainQuad("Floor", PATCH_SIZE, TOTAL_SIZE, getRandomHillHeightMap());
        terrain.setMaterial(SimpleMaterials.getMaterial(Materials.Floor));
        terrain.setLocalTranslation(LOCAL_TRANSLATION);
        terrain.addControl(control);
        physicsSpace.add(control);
        rootNode.attachChild(terrain);
    }

    /**
     * Removes the {@link TerrainQuad} from the scene.
     *
     * @see SimpleAppState
     * @see AbstractAppState
     */
    @Override
    public void cleanup() {
        super.cleanup();
        rootNode.detachChild(terrain);
    }

    /**
     * Generates a random height map with a {@link HillHeightMap} which is
     * specified by
     * {@code MAP_NORMALIZE_RANGE}, {@code MAP_ITERATIONS}, {@code MAP_MIN_RADIUS}
     * and {@code MAP_MAX_RADIUS}.
     *
     * @return A random height map generated by a {@link HillHeightMap}.
     * @throws Exception is thrown when {@link HillHeightMap} creation fails.
     */
    private float[] getRandomHillHeightMap() throws Exception {
        HillHeightMap.NORMALIZE_RANGE = MAP_NORMALIZE_RANGE;
        HillHeightMap map = new HillHeightMap(TOTAL_SIZE, MAP_ITERATIONS, MAP_MIN_RADIUS, MAP_MAX_RADIUS);
        return map.getHeightMap();
    }
}
